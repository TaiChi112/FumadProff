---
title: Common Problems in Digital Image Processing
slug: /docs/Computer_Science/DIP/Problem/
description: Comprehensive overview of common problems encountered in Digital Image Processing (DIP) and their solutions.
tags: [Computer Science, Image Processing, Technology, DIP, Image Enhancement]
date: 2024-06-15
---

# Common Problems in Digital Image Processing (DIP)

‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢‡πÉ‡∏ô Image Processing ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏ù‡∏∂‡∏Å‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏î‡πâ‡∏≤‡∏ô Digital Image Processing (DIP) ‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏±‡πâ‡∏á Preprocessing ‚Üí Processing ‚Üí Postprocessing

## Image Quality Issues

### 1. Noise (‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏ö‡∏Å‡∏ß‡∏ô)
   - **Description**: Unwanted random variations in brightness or color information in images.
   - **Techniques**: Median Filtering, Gaussian Smoothing, Bilateral Filtering, Non-Local Means
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏£‡∏ö‡∏Å‡∏ß‡∏ô ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÑ‡∏°‡πà‡∏Ñ‡∏°‡∏ä‡∏±‡∏î ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏∑‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏Å‡πà‡∏≤ ‡πÜ

| **‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Noise**        | **‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏†‡∏≤‡∏û**                | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                |
| ----------------------- | ---------------------------- | ------------------------------ |
| **Gaussian Noise**      | ‡∏à‡∏∏‡∏î‡∏£‡∏ö‡∏Å‡∏ß‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ó‡∏±‡πà‡∏ß‡∏†‡∏≤‡∏û | Gaussian Filter, Wiener Filter |
| **Salt & Pepper Noise** | ‡∏à‡∏∏‡∏î‡∏î‡∏≥-‡∏Ç‡∏≤‡∏ß‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏¢‡πà‡∏≠‡∏° ‡πÜ   | Median Filter                  |
| **Speckle Noise**       | ‡∏û‡∏ö‡πÉ‡∏ô‡∏†‡∏≤‡∏û Ultrasound           | Adaptive Filtering             |
| **Poisson Noise**       | ‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡πÇ‡∏ü‡∏ï‡∏≠‡∏ô‡πÉ‡∏ô‡∏†‡∏≤‡∏û      | Variance Stabilizing Transform |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏ö‡∏Å‡∏ß‡∏ô‡∏î‡πâ‡∏ß‡∏¢ OpenCV
import cv2
import numpy as np
from skimage.metrics import peak_signal_noise_ratio as psnr

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('noisy_image.jpg')

# ‡∏•‡∏î Gaussian Noise
gaussian_blur = cv2.GaussianBlur(img, (5, 5), 0)

# ‡∏•‡∏î Salt & Pepper Noise
median_blur = cv2.medianBlur(img, 5)

# ‡∏•‡∏î Noise ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á‡∏î‡πâ‡∏ß‡∏¢ Non-Local Means
nlm_blur = cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 21)

# ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û
print("PSNR Gaussian:", psnr(img, gaussian_blur))
print("PSNR Median:", psnr(img, median_blur))
print("PSNR NLM:", psnr(img, nlm_blur))
```

### 2. Blurring (‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠ / Out of Focus)
   - **Description**: Loss of sharpness in images, often due to camera shake or out-of-focus capture.
   - **Techniques**: Deconvolution, Wiener Filter, Blind Deconvolution, Richardson-Lucy Algorithm
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏™‡∏±‡πà‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏à‡∏∏‡∏î

| **‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏**              | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                              |
| ----------------------- | -------------------------------------------- |
| Motion Blur (‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏™‡∏±‡πà‡∏ô) | Wiener Filter, Lucy-Richardson Deconvolution |
| Out of Focus            | Laplacian Sharpening, Unsharp Masking        |
| Camera Shake            | Blind Deconvolution                          |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('blurry_image.jpg')

# 1. Unsharp Masking - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î
gaussian = cv2.GaussianBlur(img, (5, 5), 0)
unsharp_masked = cv2.addWeighted(img, 1.5, gaussian, -0.5, 0)

# 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á Motion Blur ‡πÄ‡∏ó‡∏µ‡∏¢‡∏° (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö)
kernel_size = 15
kernel_motion_blur = np.zeros((kernel_size, kernel_size))
kernel_motion_blur[int((kernel_size-1)/2), :] = np.ones(kernel_size)
kernel_motion_blur = kernel_motion_blur / kernel_size
motion_blur = cv2.filter2D(img, -1, kernel_motion_blur)

# ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
cv2.imshow("Original", img)
cv2.imshow("Enhanced (Unsharp Masked)", unsharp_masked)
cv2.waitKey(0)
```

### 3. Low Contrast (‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå‡∏ï‡πà‡∏≥)
   - **Description**: Images with poor contrast, making it difficult to distinguish between different regions.
   - **Techniques**: Histogram Equalization, Contrast Limited Adaptive Histogram Equalization (CLAHE), Gamma Correction
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå‡∏ï‡πà‡∏≥ ‡∏†‡∏≤‡∏û‡∏î‡∏π‡∏´‡∏°‡πà‡∏ô ‡∏™‡∏µ‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î ‡∏°‡∏±‡∏Å‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏û‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏¢‡πâ‡∏≠‡∏ô‡πÅ‡∏™‡∏á

| **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                                          | **‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢**                         |
| -------------------------------------------------------- | ------------------------------------ |
| Histogram Equalization                                   | ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏û       |
| CLAHE (Contrast Limited Adaptive Histogram Equalization) | ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡∏ó‡∏¢‡πå            |
| Gamma Correction                                         | ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏∑‡∏î‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('low_contrast.jpg', 0)  # ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏Ç‡∏≤‡∏ß‡∏î‡∏≥

# 1. Histogram Equalization - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
hist_eq = cv2.equalizeHist(img)

# 2. CLAHE - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡∏ó‡∏¢‡πå‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
clahe_img = clahe.apply(img)

# 3. Gamma Correction - ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á
gamma = 1.5
gamma_corrected = np.array(255 * (img / 255) ** gamma, dtype='uint8')

# ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
cv2.imshow("Original", img)
cv2.imshow("Histogram Equalized", hist_eq)
cv2.imshow("CLAHE", clahe_img)
cv2.waitKey(0)
```

## Feature and Edge Analysis

### 4. Edge Detection (‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏Ç‡∏≠‡∏ö‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î)
    - **Description**: Difficulty in accurately detecting edges in images due to noise or low contrast.
    - **Techniques**: Canny Edge Detector, Sobel Operator, Prewitt Operator, Laplacian of Gaussian (LoG)
    - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏Ç‡∏≠‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏Ç‡∏≠‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÅ‡∏ï‡πà‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÑ‡∏°‡πà‡∏î‡∏µ ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ noise ‡πÄ‡∏¢‡∏≠‡∏∞ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏≠‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡∏ï‡πà‡∏≤‡∏á‡∏ï‡πà‡∏≥

| **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**             | **‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**            |
| --------------------------- | -------------------------- |
| Sobel / Prewitt Filter      | ‡∏Ç‡∏≠‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô                 |
| Canny Edge Detection        | ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏°‡πÅ‡∏•‡∏∞‡∏•‡∏î noise |
| Laplacian of Gaussian (LoG) | ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏π‡∏á      |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏Ç‡∏≠‡∏ö‡∏†‡∏≤‡∏û
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('edge_example.jpg', 0)  # ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏Ç‡∏≤‡∏ß‡∏î‡∏≥

# ‡∏•‡∏î noise ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥ edge detection (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å)
img = cv2.GaussianBlur(img, (5, 5), 0)

# 1. Sobel Edge Detection
sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3)
sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3)
sobel_combined = cv2.magnitude(sobelx, sobely)
sobel_combined = np.uint8(sobel_combined)

# 2. Canny Edge Detection
canny_edges = cv2.Canny(img, 100, 200)  # ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ threshold ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°

# 3. Laplacian Edge Detection
laplacian = cv2.Laplacian(img, cv2.CV_64F)
laplacian = np.uint8(np.absolute(laplacian))

# ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö
cv2.imshow("Original", img)
cv2.imshow("Sobel", sobel_combined)
cv2.imshow("Canny", canny_edges)
cv2.imshow("Laplacian", laplacian)
cv2.waitKey(0)
```

### 5. Distortion (‡∏†‡∏≤‡∏û‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß)
    - **Description**: Geometric distortions in images caused by lens imperfections or perspective issues.
    - **Techniques**: Geometric Transformations, Camera Calibration, Lens Distortion Correction
    - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡πÄ‡∏•‡∏ô‡∏™‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏±‡∏Å‡∏à‡∏∞‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏Ñ‡πâ‡∏á ‡πÄ‡∏ä‡πà‡∏ô Fish-eye ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ñ‡πà‡∏≤‡∏¢‡∏°‡∏∏‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏π‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß

| **‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Distortion**                | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                |
| ------------------------------------ | ------------------------------ |
| Barrel Distortion (‡∏Ç‡∏≠‡∏ö‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏á‡∏≠‡∏≠‡∏Å)     | Camera Calibration + Remapping |
| Pincushion Distortion (‡∏Ç‡∏≠‡∏ö‡∏†‡∏≤‡∏û‡∏´‡∏î‡πÄ‡∏Ç‡πâ‡∏≤) | Camera Calibration             |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ distortion
img = cv2.imread('distorted_image.jpg')

# ‡∏™‡∏£‡πâ‡∏≤‡∏á camera matrix ‡πÅ‡∏•‡∏∞ distortion coefficients (‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£ calibrate ‡∏Å‡∏•‡πâ‡∏≠‡∏á)
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á parameters (‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£ calibrate ‡∏à‡∏£‡∏¥‡∏á)
camera_matrix = np.array([[800, 0, img.shape[1]/2], 
                          [0, 800, img.shape[0]/2], 
                          [0, 0, 1]])
dist_coeffs = np.array([-0.2, 0.1, 0, 0])  # k1, k2, p1, p2

# ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç distortion
undistorted_img = cv2.undistort(img, camera_matrix, dist_coeffs)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original (Distorted)", img)
cv2.imshow("Corrected", undistorted_img)
cv2.waitKey(0)

# ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ calibrate ‡∏Å‡∏•‡πâ‡∏≠‡∏á ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ‡∏ä‡∏∏‡∏î‡∏†‡∏≤‡∏û chessboard pattern ‡∏´‡∏•‡∏≤‡∏¢ ‡πÜ ‡∏†‡∏≤‡∏û
```

### 6. Thresholding & Segmentation
    - **Description**: Difficulty in segmenting objects from the background due to shadows or uneven lighting.
    - **Techniques**: Adaptive Thresholding, Otsu's Binarization, Watershed Algorithm, Grabcut
    - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å background ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÄ‡∏á‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠ ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏¢‡∏≤‡∏Å

| **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**         | **‡∏Å‡∏£‡∏ì‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**        |
| ----------------------- | --------------------- |
| Global Threshold (Otsu) | ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏á‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠     |
| Adaptive Threshold      | ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠  |
| Watershed Segmentation  | ‡πÅ‡∏¢‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô |
| GrabCut                 | ‡πÅ‡∏¢‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô       |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Segmentation
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('object.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 1. Global Thresholding (Otsu)
ret, thresh_otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 2. Adaptive Thresholding
adaptive_thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                        cv2.THRESH_BINARY, 11, 2)

# 3. Watershed Segmentation (‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô)
# ‡∏™‡∏£‡πâ‡∏≤‡∏á marker ‡∏à‡∏≤‡∏Å foreground ‡πÅ‡∏•‡∏∞ background
ret, markers = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
markers = np.int32(markers)
watershed_result = img.copy()
cv2.watershed(img, markers)
watershed_result[markers == -1] = [0, 0, 255]  # ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original", img)
cv2.imshow("Otsu Thresholding", thresh_otsu)
cv2.imshow("Adaptive Thresholding", adaptive_thresh)
cv2.imshow("Watershed", watershed_result)
cv2.waitKey(0)
```

## Lighting and Color Challenges

### 7. Illumination Variations (‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠)
   - **Description**: Uneven lighting conditions causing parts of the image to be too bright or too dark.
   - **Techniques**: Histogram Equalization, Adaptive Histogram Equalization (CLAHE), Gamma Correction, Retinex Algorithms
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß‡∏ñ‡∏∂‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏á‡∏≤‡∏°‡∏∑‡∏î

| **‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏±‡∏ç‡∏´‡∏≤**         | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                        |
| ----------------------- | -------------------------------------- |
| Uneven Lighting         | Histogram Equalization, CLAHE         |
| Shadows                 | Shadow Removal Techniques              |
| Highlights               | Highlight Recovery Techniques          |
| Low Light               | Multi-Scale Retinex                    |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÅ‡∏™‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('uneven_light.jpg')

# ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô LAB color space (L=‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á, A=‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß-‡πÅ‡∏î‡∏á, B=‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô-‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á)
lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
l, a, b = cv2.split(lab)

# ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ä‡πà‡∏≠‡∏á L (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á) ‡∏î‡πâ‡∏ß‡∏¢ CLAHE
clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
cl = clahe.apply(l)

# ‡∏£‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ‡∏Å‡∏•‡∏±‡∏ö
updated_lab = cv2.merge((cl, a, b))

# ‡πÅ‡∏õ‡∏•‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô BGR
corrected_img = cv2.cvtColor(updated_lab, cv2.COLOR_LAB2BGR)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original", img)
cv2.imshow("Corrected", corrected_img)
cv2.waitKey(0)
```

### 8. Color Issues (‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏™‡∏µ)
    - **Description**: Problems related to color accuracy and consistency in images.
    - **Techniques**: Color Correction, White Balance Adjustment, Color Space Transformation
    - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏™‡∏µ‡∏ú‡∏¥‡∏î‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô‡∏à‡∏≤‡∏Å‡πÅ‡∏™‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á

| **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**          | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                              |
| ------------------ | -------------------------------------------- |
| White Balance ‡∏ú‡∏¥‡∏î  | Gray World Algorithm                         |
| ‡∏†‡∏≤‡∏û‡∏™‡∏µ‡∏´‡∏°‡πà‡∏ô          | HSV Color Enhancement                        |
| ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ô‡πâ‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏µ | Masking + Color Space Conversion (BGR ‚Üí HSV) |
| Color Cast         | Color Transfer, Color Grading                |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏™‡∏µ
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('color_problem.jpg')

# 1. Gray World Algorithm (White Balance)
def gray_world(img):
    # ‡πÅ‡∏¢‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ
    b, g, r = cv2.split(img)
    
    # ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ
    r_avg = np.mean(r)
    g_avg = np.mean(g)
    b_avg = np.mean(b)
    
    # ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏£‡∏ß‡∏°
    avg = (r_avg + g_avg + b_avg) / 3
    
    # ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏™‡∏µ
    r = r * (avg / r_avg)
    g = g * (avg / g_avg)
    b = b * (avg / b_avg)
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 255
    r = np.clip(r, 0, 255).astype(np.uint8)
    g = np.clip(g, 0, 255).astype(np.uint8)
    b = np.clip(b, 0, 255).astype(np.uint8)
    
    # ‡∏£‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ‡∏Å‡∏•‡∏±‡∏ö
    return cv2.merge([b, g, r])

# 2. ‡πÅ‡∏¢‡∏Å‡∏™‡∏µ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ (‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏µ‡πÅ‡∏î‡∏á)
def extract_red(img):
    # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô HSV
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    
    # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á (HSV)
    lower_red1 = np.array([0, 100, 100])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([160, 100, 100])
    upper_red2 = np.array([179, 255, 255])
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á mask
    mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
    mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
    mask = mask1 + mask2
    
    # ‡∏ô‡∏≥ mask ‡πÑ‡∏õ‡∏Ñ‡∏π‡∏ì‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
    result = cv2.bitwise_and(img, img, mask=mask)
    return result

# ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
white_balanced = gray_world(img)
red_only = extract_red(img)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original", img)
cv2.imshow("White Balanced", white_balanced)
cv2.imshow("Red Only", red_only)
cv2.waitKey(0)
```

### 9. Color Distortion (‡∏™‡∏µ‡∏ú‡∏¥‡∏î‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô)
   - **Description**: Inaccurate color representation due to lighting conditions or camera settings.
   - **Techniques**: Color Correction, White Balance Adjustment, Color Space Transformation, Color Transfer
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏™‡∏µ‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏µ‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô‡∏à‡∏≤‡∏Å‡πÅ‡∏™‡∏á‡πÑ‡∏ü‡∏ü‡∏•‡∏π‡∏≠‡∏≠‡πÄ‡∏£‡∏™‡πÄ‡∏ã‡∏ô‡∏ï‡πå ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ñ‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢

| **‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏±‡∏ç‡∏´‡∏≤**         | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                        |
| ----------------------- | -------------------------------------- |
| Color Cast              | White Balance Adjustment               |
| Faded Colors            | Color Correction                       |
| Low Saturation          | Saturation Adjustment                  |
| Mixed Lighting Sources  | Color Temperature Correction           |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏™‡∏µ‡∏î‡πâ‡∏ß‡∏¢ LAB Color Space
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('color_distorted.jpg')

# ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô LAB color space (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏™‡∏µ)
lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
l, a, b = cv2.split(lab)

# ‡∏õ‡∏£‡∏±‡∏ö A channel (‡πÅ‡∏Å‡∏ô ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß-‡πÅ‡∏î‡∏á)
a = cv2.add(a, 5)  # ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏™‡∏µ‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏î‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô

# ‡∏õ‡∏£‡∏±‡∏ö B channel (‡πÅ‡∏Å‡∏ô ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô-‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á)
b = cv2.add(b, -5)  # ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏™‡∏µ‡∏≠‡∏≠‡∏Å‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô

# ‡∏£‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏™‡∏µ‡∏Å‡∏•‡∏±‡∏ö
corrected_lab = cv2.merge((l, a, b))
corrected_img = cv2.cvtColor(corrected_lab, cv2.COLOR_LAB2BGR)

# ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á‡∏™‡∏µ (Saturation)
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
h, s, v = cv2.split(hsv)
s = cv2.multiply(s, 1.3)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á‡∏™‡∏µ 30%
s = np.clip(s, 0, 255).astype(np.uint8)
saturated_hsv = cv2.merge([h, s, v])
saturated_img = cv2.cvtColor(saturated_hsv, cv2.COLOR_HSV2BGR)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original", img)
cv2.imshow("Color Corrected (LAB)", corrected_img)
cv2.imshow("Saturation Enhanced", saturated_img)
cv2.waitKey(0)
```

## Advanced Challenges

### 10. Compression Artifacts (‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏ö‡∏Å‡∏ß‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î)
   - **Description**: Loss of image quality due to lossy compression techniques.
   - **Techniques**: Artifact Reduction Filters, Super-Resolution Techniques, Deep Learning Methods
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏ö‡∏Å‡∏ß‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î ‡πÄ‡∏ä‡πà‡∏ô ‡∏†‡∏≤‡∏û JPEG ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏≠‡∏ö‡∏´‡∏¢‡∏±‡∏Å

| **‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏±‡∏ç‡∏´‡∏≤**         | **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                        |
| ----------------------- | -------------------------------------- |
| Blocking Artifacts      | Block Matching, Inpainting            |
| Blurring                | Deblurring Techniques                 |
| Color Banding           | Dithering, Color Space Transformation |
| JPEG Compression        | JPEG Artifact Removal Filters         |

üí° **‡∏ù‡∏∂‡∏Å‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥**:
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Code ‡∏Å‡∏≤‡∏£‡∏•‡∏î Compression Artifacts
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û
img = cv2.imread('compressed_image.jpg')

# 1. ‡πÉ‡∏ä‡πâ Non-local Means Denoising (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö Compression Artifacts)
denoised = cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 21)

# 2. ‡πÉ‡∏ä‡πâ Bilateral Filter (‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Ç‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏î noise)
bilateral = cv2.bilateralFilter(img, 9, 75, 75)

# 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î‡∏´‡∏•‡∏±‡∏á‡∏•‡∏î artifacts
kernel = np.array([[-1, -1, -1],
                   [-1, 9, -1],
                   [-1, -1, -1]])
sharpened = cv2.filter2D(denoised, -1, kernel)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
cv2.imshow("Original (Compressed)", img)
cv2.imshow("Denoised (NLM)", denoised)
cv2.imshow("Bilateral Filter", bilateral)
cv2.imshow("Sharpened After Denoising", sharpened)
cv2.waitKey(0)
```

### 11. Image Resolution Enhancement
   - **Description**: Need to improve the resolution of low-quality images.
   - **Techniques**: Super-Resolution, Deep Learning (SRGAN, ESRGAN), Interpolation
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤**: ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡πà‡∏≥ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ú‡∏¥‡∏î‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô

| **‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ**                  | **‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢**                                    |
| --------------------------- | ---------------------------------------------- |
| Bicubic Interpolation       | ‡∏ß‡∏¥‡∏ò‡∏µ‡∏î‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏¥‡∏° ‡∏á‡πà‡∏≤‡∏¢‡πÅ‡∏ï‡πà‡πÑ‡∏î‡πâ‡∏ú‡∏•‡πÑ‡∏°‡πà‡∏î‡∏µ‡∏°‡∏≤‡∏Å               |
| SRGAN                       | ‡πÉ‡∏ä‡πâ GAN ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û |
| ESRGAN                      | ‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏à‡∏≤‡∏Å SRGAN ‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤                   |
| Real-ESRGAN                 | ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á             |

üí° **‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏**:
- PSNR (Peak Signal-to-Noise Ratio) ‡πÅ‡∏•‡∏∞ SSIM (Structural Similarity Index) ‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏î‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
- ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ OpenCV ‡∏´‡∏£‡∏∑‡∏≠ scikit-image ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ï‡πà‡∏≤‡∏á ‡πÜ ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏±‡∏Å‡∏©‡∏∞‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÉ‡∏ô Digital Image Processing (DIP) ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô

## Practical Workflow

**Roadmap ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ù‡∏∂‡∏Å**

1. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Preprocessing
   - Noise Removal ‚Üí Histogram Equalization ‚Üí Sharpening
2. Processing
   - Edge Detection ‚Üí Segmentation ‚Üí Morphological Operations
3. Postprocessing
   - Object Tracking ‚Üí Feature Extraction ‚Üí Classification

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏à‡∏ó‡∏¢‡πå**
- ‡∏°‡∏µ‡∏†‡∏≤‡∏û‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÄ‡∏Å‡πà‡∏≤ ‡πÜ ‡∏ó‡∏µ‡πà‡∏ñ‡πà‡∏≤‡∏¢‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ ‚Üí ‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠ + ‡∏°‡∏µ noise + ‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå‡∏ï‡πà‡∏≥

**‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:**
1. Noise Removal ‚Üí Median Filter
2. Sharpening ‚Üí Unsharp Mask
3. Contrast Enhancement ‚Üí CLAHE
4. Thresholding ‚Üí Adaptive Threshold

```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Complete Pipeline ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£
import cv2
import numpy as np

# ‡∏≠‡πà‡∏≤‡∏ô‡∏†‡∏≤‡∏û‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£
document = cv2.imread('document_image.jpg')

# 1. ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏Ç‡∏≤‡∏ß‡∏î‡∏≥
gray = cv2.cvtColor(document, cv2.COLOR_BGR2GRAY)

# 2. ‡∏•‡∏î noise ‡∏î‡πâ‡∏ß‡∏¢ Median Filter
denoised = cv2.medianBlur(gray, 5)

# 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î‡∏î‡πâ‡∏ß‡∏¢ Unsharp Masking
gaussian = cv2.GaussianBlur(denoised, (0, 0), 3)
unsharp_masked = cv2.addWeighted(denoised, 1.5, gaussian, -0.5, 0)

# 4. ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå‡∏î‡πâ‡∏ß‡∏¢ CLAHE
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
enhanced = clahe.apply(unsharp_masked)

# 5. ‡∏ó‡∏≥ Thresholding ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
adaptive_thresh = cv2.adaptiveThreshold(enhanced, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                        cv2.THRESH_BINARY, 11, 2)

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô
cv2.imshow("Original", document)
cv2.imshow("Denoised", denoised)
cv2.imshow("Contrast Enhanced", enhanced)
cv2.imshow("Final Document", adaptive_thresh)
cv2.waitKey(0)
```

## ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏•‡∏∞‡πÅ‡∏´‡∏•‡πà‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ

**‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠**
- **OpenCV** ‚Üí ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ù‡∏∂‡∏Å coding (cv2) ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô ‡πÉ‡∏ä‡πâ‡∏á‡πà‡∏≤‡∏¢ ‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
- **Scikit-image** ‚Üí ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö image processing ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ß‡∏¥‡∏ä‡∏≤‡∏Å‡∏≤‡∏£ Python Native API
- **ImageJ** ‚Üí ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏†‡∏≤‡∏û‡∏ó‡∏≤‡∏á‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå GUI ‡∏™‡∏∞‡∏î‡∏ß‡∏Å
- **Pillow** ‚Üí Python Imaging Library ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
- **MATLAB Image Processing Toolbox** ‚Üí ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ß‡∏¥‡∏à‡∏±‡∏¢‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
- **TensorFlow/PyTorch** ‚Üí ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢ Deep Learning

**‡πÅ‡∏´‡∏•‡πà‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ**
- OpenCV Documentation: https://docs.opencv.org/
- Digital Image Processing by Gonzalez and Woods (‡∏ï‡∏≥‡∏£‡∏≤‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏¥‡∏Å)
- pyimagesearch.com (‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏° DIP ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢)
- Kaggle Notebooks ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Image Processing

## ‡∏™‡∏£‡∏∏‡∏õ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏†‡∏≤‡∏û

| **‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û** | **‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**                | **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏ô OpenCV**               |
| -------------- | ---------------------------------- | ---------------------------------- |
| ‡∏à‡∏∏‡∏î‡∏£‡∏ö‡∏Å‡∏ß‡∏ô       | Noise Reduction (Gaussian, Median) | cv2.GaussianBlur(), cv2.medianBlur() |
| ‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠        | Deblurring, Wiener Filter         | cv2.filter2D(), cv2.Wiener()       |
| ‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏£‡∏≤‡∏™‡∏ï‡πå‡∏ï‡πà‡∏≥   | Histogram Equalization, CLAHE      | cv2.equalizeHist(), cv2.createCLAHE() |
| ‡∏Ç‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î      | Canny Edge Detection               | cv2.Canny()                        |
| ‡∏†‡∏≤‡∏û‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß   | Camera Calibration                 | cv2.undistort(), cv2.calibrateCamera() |
| ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô   | Watershed Segmentation             | cv2.watershed()                    |
| ‡∏™‡∏µ‡∏ú‡∏¥‡∏î‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô    | White Balance, HSV Masking         | cv2.cvtColor(), cv2.inRange()      |
| ‡∏Å‡∏≤‡∏£‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î      | Artifact Reduction                 | cv2.fastNlMeansDenoisingColored() |
| ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡πà‡∏≥ | Super-Resolution                  | Deep learning frameworks           |
